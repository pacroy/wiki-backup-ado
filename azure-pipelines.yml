name: $(Date:yyyyMMdd)$(Rev:.r).$(BuildID)

trigger: none
pr: none

schedules:
- cron: "0 0 * * 0"
  displayName: 'Weekly - Sunday Midnight'
  branches:
    include:
    - main
  always: true
  
pool:
  vmImage: 'ubuntu-20.04'

parameters:
- name: 'isDryRun'
  displayName: 'Dry-run'
  type: boolean
  default: false

jobs:
- job: 'backup'
  displayName: 'Backup Wiki'
  steps:
  - checkout: none
  - task: Bash@3
    displayName: 'Check Pipeline Variables'
    inputs:
      failOnStderr: true
      targetType: 'inline'
      script: |
        if [ -z "$TENANT_ID" ]; then >&2 echo 'Variable "TENANT_ID" is not set'; fi
        if [ -z "$SERVICE_PRINCIPAL_ID" ]; then >&2 echo 'Variable "SERVICE_PRINCIPAL_ID" is not set'; fi
        if [ -z "$(SERVICE_PRINCIPAL_SECRET)" ]; then >&2 echo 'Variable "SERVICE_PRINCIPAL_SECRET" is not set'; fi

        if [ -z "$(KUBE_CA_BASE64)" ]; then >&2 echo 'Variable "KUBE_CA_BASE64" is not set'; fi
        if [ -z "$(KUBE_CLUSTER_NAME)" ]; then >&2 echo 'Variable "KUBE_CLUSTER_NAME" is not set'; fi
        if [ -z "$(KUBE_API_SERVER)" ]; then >&2 echo 'Variable "KUBE_API_SERVER" is not set'; fi
        if [ -z "$(KUBE_SERVER_ID)" ]; then >&2 echo 'Variable "KUBE_SERVER_ID" is not set'; fi
        if [ -z "$(KUBE_CLIENT_ID)" ]; then >&2 echo 'Variable "KUBE_CLIENT_ID" is not set'; fi

        if [ -z "$KUBE_CONTEXT" ]; then >&2 echo 'Variable "KUBE_CONTEXT" is not set'; fi
        if [ -z "$WIKI_NAMSPACE" ]; then >&2 echo 'Variable "WIKI_NAMSPACE" is not set'; fi
        if [ -z "$MYSQL_APP_LABEL" ]; then >&2 echo 'Variable "MYSQL_APP_LABEL" is not set'; fi
        if [ -z "$BOOKSTACK_APP_LABEL" ]; then >&2 echo 'Variable "BOOKSTACK_APP_LABEL" is not set'; fi
        if [ -z "$BLOB_CONTAINER_NAME" ]; then >&2 echo 'Variable "BLOB_CONTAINER_NAME" is not set'; fi
        if [ -z "$STORAGE_ACCOUNT_NAME" ]; then >&2 echo 'Variable "STORAGE_ACCOUNT_NAME" is not set'; fi
  - task: Bash@3
    displayName: 'Install kubelogin'
    inputs:
      failOnStderr: false
      targetType: 'inline'
      script: |
        kubelogin_latest_tag=$(curl -fsSL https://api.github.com/repos/Azure/kubelogin/releases/latest | jq -r '.tag_name')
        kubelogin_download_url="https://github.com/Azure/kubelogin/releases/download/${kubelogin_latest_tag}/kubelogin-linux-amd64.zip"
        curl -fsSLO "${kubelogin_download_url}"
        unzip kubelogin-linux-amd64.zip
        sudo install -o root -g root -m 0755 ./bin/linux_amd64/kubelogin /usr/local/bin/kubelogin
  - task: Bash@3
    displayName: 'Print Tool Version'
    inputs:
      failOnStderr: false
      targetType: 'inline'
      script: |
        command -v az
        az version
        command -v kubectl
        kubectl version --client=true
        command -v kubelogin
        kubelogin --version
  - task: Bash@3
    displayName: 'Download Backup Script'
    inputs:
      failOnStderr: true
      targetType: 'inline'
      script: curl -fsSL https://raw.githubusercontent.com/pacroy/bookstack-backup/master/backup.sh -o backup.sh
  - task: Bash@3
    displayName: 'Login Kubernetes'
    inputs:
      failOnStderr: true
      targetType: 'inline'
      script: |
        echo "${KUBE_CA_BASE64}" | base64 -d > cert.pem
        kubectl config set-cluster "${KUBE_CLUSTER_NAME}" --server "${KUBE_API_SERVER}" --embed-certs --certificate-authority=cert.pem
        kubectl config set-credentials "clusterUser_${KUBE_CLUSTER_NAME}" --auth-provider=azure \
          --auth-provider-arg="apiserver-id=${KUBE_SERVER_ID}" \
          --auth-provider-arg="client-id=${KUBE_CLIENT_ID}" \
          --auth-provider-arg=config-mode='1' \
          --auth-provider-arg=environment=AzurePublicCloud \
          --auth-provider-arg="tenant-id=${TENANT_ID}"
        kubectl config set-context "${KUBE_CLUSTER_NAME}" --user=cluster-admin --cluster="${KUBE_CLUSTER_NAME}" --user="clusterUser_${KUBE_CLUSTER_NAME}"
        kubectl config use-context "${KUBE_CLUSTER_NAME}"

        if [ -n "${SERVICE_PRINCIPAL_ID}" ]; then
          kubelogin convert-kubeconfig -l spn
          export AAD_SERVICE_PRINCIPAL_CLIENT_ID="$(SERVICE_PRINCIPAL_ID)"
          export AAD_SERVICE_PRINCIPAL_CLIENT_SECRET="$(SERVICE_PRINCIPAL_SECRET)"
        fi

        kubectl version
  - task: Bash@3
    displayName: 'Execute Backup Script'
    inputs:
      failOnStderr: true
      targetType: 'filePath'
      filePath: backup.sh
      arguments: '-y'
    env:
      AAD_SERVICE_PRINCIPAL_CLIENT_ID: "$(SERVICE_PRINCIPAL_ID)"
      AAD_SERVICE_PRINCIPAL_CLIENT_SECRET: "$(SERVICE_PRINCIPAL_SECRET)"
  - task: Bash@3
    displayName: 'List Backup Files'
    inputs:
      failOnStderr: true
      targetType: 'inline'
      script: ls -al backup/
  - task: Bash@3
    displayName: 'Upload to Blob Storage'
    condition: eq('${{ parameters.isDryRun }}', false)
    inputs:
      failOnStderr: true
      targetType: 'inline'
      script: |
        if [ -n "${STORAGE_SUBSCRIPTION_ID}" ]; then az account set --subscription "${STORAGE_SUBSCRIPTION_ID}"; fi
        BLOB_PREFIX=$(date +%Y%m%d)
        az storage blob upload \
          --container-name "$BLOB_CONTAINER_NAME" \
          --file 'backup/bookstack.sql' \
          --name "$BLOB_PREFIX/bookstack.sql" \
          --account-name "$STORAGE_ACCOUNT_NAME" \
          --auth-mode key --only-show-errors --no-progress
        az storage blob upload \
          --container-name "$BLOB_CONTAINER_NAME" \
          --file 'backup/uploads.tgz' \
          --name "$BLOB_PREFIX/uploads.tgz" \
          --account-name "$STORAGE_ACCOUNT_NAME" \
          --auth-mode key --only-show-errors --no-progress
        az storage blob upload \
          --container-name "$BLOB_CONTAINER_NAME" \
          --file 'backup/storage.tgz' \
          --name "$BLOB_PREFIX/storage.tgz" \
          --account-name "$STORAGE_ACCOUNT_NAME" \
          --auth-mode key --only-show-errors --no-progress
  - task: Bash@3
    displayName: 'Clean up'
    inputs:
      failOnStderr: true
      targetType: 'inline'
      script: |
        kubectl config delete-context "${KUBE_CLUSTER_NAME}"
        kubectl config delete-user "clusterUser_${KUBE_CLUSTER_NAME}"
        kubectl config delete-cluster "${KUBE_CLUSTER_NAME}"
        rm -f cert.pem
